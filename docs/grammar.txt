# grammar.txt
#
# clanker shell grammar
#
# This grammar defines the syntactic structure of the clanker command
# language as it is currently accepted.
#
# Lexical structure (WORD formation, quoting, brace-groups, command
# substitution, escapes, etc.) is handled entirely by the lexer.
#
# POSIX shell grammar is an inspiration, not a constraint.
# Grammar productions are added only when their semantics are fully
# specified and implemented.
#
# ----------------------------------------------------------------------
# NOTATION (EBNF-ish)
#
#   A B        concatenation
#   A | B      alternation
#   [A]        optional
#   {A}        repetition (0..n)
#   (A)        grouping
#
# ----------------------------------------------------------------------
# LEXICAL SUMMARY (NORMATIVE)
#
# 1) Whitespace is treated as in C.
#    Outside of WORD constructs, whitespace separates tokens.
#    Inside WORD constructs, whitespace is literal.
#
# 2) NEWLINE is a command terminator like ';' unless the parser is waiting
#    for completion (open construct, trailing operator, etc.).
#
# 3) WORD is produced by the lexer and treated as opaque by the parser.
#    WORD may contain:
#      - unquoted text
#      - single quotes        '...'
#      - double quotes        "..."
#      - triple quotes        '''...'''  """..."""
#      - brace-groups         {...}   (nesting allowed)
#      - command substitution $(...) or `...`
#      - escapes              \c and \<newline>
#
# 4) Operators are recognized even when adjacent to WORDs.
#
# 5) Brace expansion is an execution-phase transformation.
#    Grammar does not assign semantics to brace-groups.
#
# ----------------------------------------------------------------------
# TOKENS
#
# Operators (longest match wins):
#   "&&"  "||"
#   "|"
#   ";"   "&"
#
# Other tokens:
#   WORD
#   NEWLINE
#
# ----------------------------------------------------------------------
# START SYMBOL
#

program
  ::= { command terminator }
      [ command ]
      [ terminator ]
      EOF ;

terminator
  ::= ";" | NEWLINE ;

EOF
  ::= <end of input> ;

# ----------------------------------------------------------------------
# COMMAND STRUCTURE
#
# Operator precedence (tightest â†’ loosest):
#   1) simple command
#   2) pipeline        |
#   3) logical AND/OR  && ||
#   4) sequential list ; NEWLINE
#

command
  ::= and_or ;

and_or
  ::= pipeline
      { ( "&&" | "||" ) pipeline } ;

pipeline
  ::= simple_command
      { "|" simple_command } ;

# ----------------------------------------------------------------------
# SIMPLE COMMANDS
#
# A simple command is a sequence of WORDs.
# Redirections, assignments, compound commands, and functions are
# intentionally excluded at this stage.
#

simple_command
  ::= WORD { WORD } ;

# ----------------------------------------------------------------------
# PARSE COMPLETENESS
#
# Input is incomplete if:
#   - an open quote, brace-group, or command substitution is not closed
#   - the input ends with '|', '&&', or '||'
#   - a trailing backslash escapes the newline
#
# Incomplete input causes the parser to request more input.
#
# ----------------------------------------------------------------------
# EXTENSION POLICY
#
# Grammar productions are added only when:
#   - their syntax is fully specified
#   - their execution semantics are documented
#   - they are implemented and tested
#
# Planned extensions (not yet grammatical):
#   - background execution ('&')
#   - redirections
#   - assignments
#   - compound commands
#   - functions
#
# ----------------------------------------------------------------------
# END OF GRAMMAR

