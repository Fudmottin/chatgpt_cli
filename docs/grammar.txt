# grammar.txt
#
# clanker shell grammar
#
# This grammar defines the syntactic structure of the clanker command
# language.  Lexical structure (WORD formation, quoting, brace-groups,
# command substitution, etc.) is handled entirely by the lexer.
#
# POSIX shell grammar is a guide, not a constraint.
#
# Notation (EBNF-ish):
#   A B        concatenation
#   A | B      alternation
#   [A]        optional
#   {A}        repetition (0..n)
#   (A)        grouping
#
# ----------------------------------------------------------------------
# LEXICAL SUMMARY (NORMATIVE)
#
# 1) Whitespace is treated as in C.
#    Outside of WORD constructs, whitespace separates tokens.
#    Inside WORD constructs, whitespace is literal and does not split
#    tokens.
#
# 2) NEWLINE is a command terminator like ';' unless the parser is waiting
#    for completion (open construct, trailing operator, etc.).
#
# 3) WORD is produced by the lexer and treated as opaque by the parser.
#    WORD may contain:
#      - unquoted text
#      - single quotes        '...'
#      - double quotes        "..."
#      - triple quotes        '''...'''  """..."""
#      - brace-groups         {...}   (nesting allowed)
#      - command substitution $(...) or `...`
#      - escapes              \c and \<newline>
#
# 4) Operators are recognized even when adjacent to WORDs.
#
# 5) Brace expansion is an execution-phase transformation. In brace
# expansions, commas separate elements; whitespace around commas is ignored;
# whitespace within an element is preserved.
#
# ----------------------------------------------------------------------
# TOKENS
#
# Operators (longest match wins):
#   "&&" "||"
#   "|&" "|"
#   ">" "<" ">>"
#   ";" "&"
#   "(" ")" "{" "}"
#
# Reserved words (recognized only in command position):
#   if then elif else fi
#   for in do done
#   while until case esac
#   function select
#   time
#
# Word-like tokens:
#   WORD
#   ASSIGNMENT_WORD   NAME '=' WORD?
#   IO_NUMBER         [0-9]+ immediately before redirection
#
# ----------------------------------------------------------------------
# START SYMBOLS
#

program
  ::= { complete_command terminator }
      [ complete_command ]
      [ terminator ]
      EOF ;

terminator
  ::= ";" | NEWLINE ;

complete_command
  ::= list ;

EOF
  ::= <end of input> ;

# ----------------------------------------------------------------------
# LISTS, LOGICAL OPERATORS, PIPELINES
#
# Precedence (tightest â†’ loosest):
#   1) simple command elements
#   2) pipeline
#   3) && ||
#   4) sequential list (; & NEWLINE)
#

list
  ::= and_or
      { ( ";" | "&" | NEWLINE ) and_or }
      [ ( ";" | "&" | NEWLINE ) ] ;

and_or
  ::= pipeline
      { ( "&&" | "||" ) linebreak pipeline } ;

pipeline
  ::= [ "!" ] pipe_sequence ;

pipe_sequence
  ::= command
      { ( "|" | "|&" ) linebreak command } ;

linebreak
  ::= { NEWLINE } ;

# ----------------------------------------------------------------------
# COMMANDS
#

command
  ::= simple_command
   | compound_command [ redirect_list ]
   | function_definition ;

# ----------------------------------------------------------------------
# SIMPLE COMMANDS
#
# POSIX-shaped: assignments, words, and redirections may appear in
# nearly any order.
#

simple_command
  ::= { prefix } [ command_name { element } ] ;

prefix
  ::= ASSIGNMENT_WORD
   | redirection ;

element
  ::= WORD
   | redirection ;

command_name
  ::= WORD ;

redirect_list
  ::= { redirection } ;

# ----------------------------------------------------------------------
# REDIRECTIONS
#
# Targets are WORDs; expansion semantics are defined elsewhere.
#

redirection
  ::= [ IO_NUMBER ] redir_op WORD ;

redir_op
  ::= ">"
   | ">>"
   | "<"
   | "<>"
   | ">|"
   | "<&"
   | ">&" ;

# ----------------------------------------------------------------------
# COMPOUND COMMANDS
#

compound_command
  ::= brace_group
   | subshell
   | if_clause
   | while_clause
   | until_clause
   | for_clause
   | case_clause ;

brace_group
  ::= "{" linebreak compound_list "}" ;

subshell
  ::= "(" linebreak compound_list ")" ;

compound_list
  ::= and_or
      { ( ";" | NEWLINE ) and_or }
      [ ( ";" | NEWLINE ) ] ;

# ----------------------------------------------------------------------
# CONDITIONALS AND LOOPS
#

if_clause
  ::= "if" compound_list "then" compound_list
      { "elif" compound_list "then" compound_list }
      [ "else" compound_list ]
      "fi" ;

while_clause
  ::= "while" compound_list "do" compound_list "done" ;

until_clause
  ::= "until" compound_list "do" compound_list "done" ;

for_clause
  ::= "for" NAME
      [ linebreak "in" { WORD } ]
      list_terminator
      "do" compound_list "done" ;

list_terminator
  ::= ";" | NEWLINE ;

# ----------------------------------------------------------------------
# CASE
#

case_clause
  ::= "case" WORD "in" linebreak
      { case_item }
      "esac" ;

case_item
  ::= pattern_list ")"
      linebreak
      [ compound_list ]
      case_terminator ;

pattern_list
  ::= pattern { "|" pattern } ;

pattern
  ::= WORD ;

case_terminator
  ::= ";;" | ";&" | ";|" | NEWLINE ;

# ----------------------------------------------------------------------
# FUNCTIONS
#

function_definition
  ::= function_name "(" ")" linebreak function_body
   | "function" function_name linebreak function_body ;

function_name
  ::= NAME ;

function_body
  ::= compound_command [ redirect_list ] ;

NAME
  ::= <shell identifier: [A-Za-z_][A-Za-z0-9_]* > ;

# ----------------------------------------------------------------------
# WORD (LEXICAL, NOT PARSED)
#
# WORD structure is defined by the lexer.
# The parser treats WORD as an atomic token.
#
# Triple-quoted strings replace POSIX here-documents.
# Backticks follow bash/zsh-compatible semantics.
#
# ----------------------------------------------------------------------
# END OF GRAMMAR
#

